#!/usr/bin/env python

# Rewritten from bash to python 3/2/2014 for charm helper inclusion
# of SSL-Everywhere!
import base64
from jinja2 import Template
import os
from os.path import exists as exist
from os.path import join
import shutil
import subprocess
from charmhelpers.contrib import ssl
from charmhelpers.core import hookenv
from charmhelpers.core import host


# Gather facts
legacy_relations = hookenv.config('legacy')
extra_config = hookenv.config('extraconfig')
ssl_config = hookenv.config('ssl')
charm_dir = os.environ['CHARM_DIR']
cert_domain = hookenv.config('ssl_domain')


# Checks the charm relations for legacy relations
# Inserts warnings into the log about legacy relations, as they will be removed
# in the future
def warn_legacy_relations():
    if legacy_relations is not None:
        hookenv.log("Relations have been radically changed."
                    " The monitoring interface is not supported anymore.",
                    "WARNING")
    hookenv.log("Please use the generic juju-info or the monitors interface",
                "WARNING")


# If the charm has extra configuration provided, write that to the
# proper nagios3 configuration file, otherwise remove the config
def write_extra_config():
    # Be predjudice about this - remove the file always.
    if host.file_hash('/etc/nagios3/conf.d/extra.cfg') is not None:
        os.remove('/etc/nagios3/conf.d/extra.cfg')
    # If we have a config, then write it. the hook reconfiguration will
    # handle the details
    if extra_config is not None:
        host.write_file('/etc/nagios3/conf.d/extra.cfg', extra_config)


def ssl_configured():
    allowed_options = ["on", "forced"]

    if str(ssl_config).lower() in allowed_options:
        return True
    return False


# Gather local facts for SSL deployment
deploy_key_path = join(charm_dir, 'data', '%s.key' % (cert_domain))
deploy_cert_path = join(charm_dir, 'data', '%s.crt' % (cert_domain))
deploy_csr_path = join(charm_dir, 'data', '%s.csr' % (cert_domain))
# set basename for SSL key locations
cert_file = '/etc/ssl/certs/%s.pem' % (cert_domain)
key_file = '/etc/ssl/private/%s.key' % (cert_domain)
chain_file = '/etc/ssl/certs/%s.csr' % (cert_domain)


# Check for key and certificate, since the CSR is optional
# leave it out of the dir file check and let the config manager
# worry about it
def check_ssl_files():
    key = exist(deploy_key_path)
    cert = exist(deploy_cert_path)
    if key is False or cert is False:
        return False
    return True


# Copy SSL keys from charms data dir to respective locations
def copy_ssl_keys():
     #We are copying keys, do so now
    shutil.copy(deploy_cert_path, cert_file)
    shutil.copy(deploy_key_path, key_file)
    if exist(deploy_csr_path):
        shutil.copy(deploy_csr_path, chain_file)


# Decode the SSL keys from their base64 encoded values in the configuration
def decode_ssl_keys():
    if hookenv.config('ssl_key'):
        hookenv.log("Writing key from config ssl_key: %s" % key_file)
        with open(key_file, 'w') as f:
            f.write(str(base64.b64decode(hookenv.config('ssl_key'))))
    if hookenv.config('ssl_cert'):
        with open(cert_file, 'w') as f:
            f.write(str(base64.b64decode(hookenv.config('ssl_cert'))))
    if hookenv.config('ssl_chain'):
        with open(chain_file, 'w') as f:
            f.write(str(base64.b64decode(hookenv.config('ssl_cert'))))


def enable_ssl():
    # Set the basename of all ssl files

    #Validate that we have configs, and generate a self signed certificate.
    if str(hookenv.config('ssl_cert')).lower() == "selfsigned":
        # Generate a self signed key using CharmHelpers
        hookenv.log("Generating Self Signed Certificate", "INFO")
        ssl.generate_selfsigned(key_file, cert_file, cn=cert_domain)
    else:
        #Determine if we need to copy files or decode them
        if check_ssl_files():
            copy_ssl_keys()
            hookenv.log("Copied SSL files, bailing", "DEBUG")
            return
        decode_ssl_keys()
        hookenv.log("Decoded SSL files, bailing", "DEBUG")


# Nagios3 is deployed as a global apache application from the archives.
# We'll get a little funky and add the SSL keys to the default-ssl config
# which sets our keys, including the self-signed ones, as the host keyfiles.
# note: i tried to use cheetah, and it barfed, several times. It can go play
# in a fire. I'm jusing jinja2.
def update_apache():
    if exist(chain_file):
        ssl_chain = chain_file
    template_values = {'ssl_key': key_file,
                       'ssl_cert': cert_file,
                       'ssl_chain': ssl_chain}
    with open('hooks/templates/default-ssl.tmpl', 'r') as f:
        templateDef = f.read()

    t = Template(templateDef)
    with open('/etc/apache2/sites-available/default-ssl', 'w') as f:
        f.write(t.render(template_values))
    if ssl == "only":
        subprocess.call(['a2dissite', 'default'])
    subprocess.call(['a2ensite', 'default-ssl'])
    host.service_reload('apache2')


warn_legacy_relations()
write_extra_config()
if ssl_configured():
    enable_ssl()
    update_apache()

subprocess.call(['hooks/mymonitors-relation-joined'])
subprocess.call(['hooks/monitors-relation-changed'])
